% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/config_create.R
\name{config.create}
\alias{config.create}
\title{Creates a \code{data.frame} with a configuration to control the behaviour of \code{tryCatchLogExt()}}
\usage{
config.create(
  cond.class = c("error", "warning", "message", "condition", "interrupt"),
  silent = c(FALSE, FALSE, FALSE, TRUE, FALSE),
  write.to.log = c(TRUE, TRUE, TRUE, FALSE, TRUE),
  log.as.severity = c(tryCatchLog::Severity.Levels$ERROR,
    tryCatchLog::Severity.Levels$WARN, tryCatchLog::Severity.Levels$INFO,
    tryCatchLog::Severity.Levels$DEBUG, tryCatchLog::Severity.Levels$FATAL),
  include.full.call.stack = c(TRUE, TRUE, FALSE, FALSE, TRUE),
  include.compact.call.stack = c(TRUE, TRUE, TRUE, TRUE, TRUE)
)
}
\arguments{
\item{cond.class}{The class name of the condition as character (eg. "error")}

\item{silent}{\code{\link{logical}}: \code{TRUE} = do not propagate the condition to other registered handlers (= "muffle" in R speak).
                       Global settings like \code{\link{getOption}("warn")} are still affecting the further propagation
                       (see \code{\link{warning}}).
                       It will be logged by calling the according logging function if \code{write.to.log} is \code{TRUE}.
                       The logging framework may still decide to suppress the log output eg. by severity level filtering.
Note that some condition classes cannot be muffled (no support for that in base R), eg. \code{error}
and this setting will be ignored then.}

\item{write.to.log}{\code{\link{logical}}: \code{TRUE} = Call the logging functon for the caught condition)
TODO: Document behaviour if tryCatchLog() is called with logged.conditions = c("myCondition") etc... Who wins?}

\item{log.as.severity}{Severity level for the \code{cond.class} (use the constants from \code{\link{Severity.Levels}} or the equivalent character strings)}

\item{include.full.call.stack}{Flag of type \code{\link{logical}}:
Shall the full call stack be included in the log output? Since the full
call stack may be very long and the compact call stack has enough details
normally the full call stack can be omitted by passing \code{FALSE}.
The default value can be changed globally by setting the option \code{tryCatchLog.include.full.call.stack}.
The full call stack can always be found via \code{\link{last.tryCatchLog.result}}.}

\item{include.compact.call.stack}{Flag of type \code{\link{logical}}:
Shall the compact call stack (including only calls with source code references)
be included in the log output? Note: If you omit both the full and compact
call stacks the message text will be output without call stacks.
The default value can be changed globally by setting the option \code{tryCatchLog.include.compact.call.stack}.
 The compact call stack can always be found via \code{\link{last.tryCatchLog.result}}.}
}
\value{
A \code{data.frame} with the created configuration (marked with the class \code{tryCatchLog.config})
}
\description{
This configuration can be much more detailed eg. by specifying the \code{tryCatchLog} behaviour
per condition class (even for custom condition classes).
}
\details{
The configuration can also be saved into and loaded from a CSV file for reusability
and to allow "external" configurations (without changing code).

The arguments pass the column values of the configuration and therefore must be vectors of the same length.

Each row of the configuration specifies the behavior for one condition class

The default values create a simple configuration that can be used as example
or to be extended (eg. by saving it as CSV file that can be edited then).

TODO Clarify who wins in case of conflicts: The function call argument or the configuration?
TODO Explain what happens if a condition inherits from multiple configuration row classes (who wins?)!
     -> if a condition inherits from multiple classes the class attribute looks like this:
          > x <- simpleWarning("a")
          > class(x)
          [1] "simpleWarning" "warning"       "condition"
        so processing the class vector from left to right to find the first matching row for this class
        is the correct way to apply the most specific configuration.
}
\examples{
config <- tryCatchLog::config.create()
config.save(config, "my_tryCatchLog_config.csv")
# Severity levels are defined as strings in a package variable, eg:
print(tryCatchLog::Severity.Levels$INFO)

}
