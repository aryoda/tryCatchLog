---
title: "Error handling in R with tryCatchLog<br>(catch, log, post-mortem analysis)"
author: Jürgen Altfeld
date: Dec. 2016
output:
        revealjs::revealjs_presentation:
          self_contained: true
          center: false
          height: 1050
          width: 1680
          reveal_options:
            slideNumber: true
            previewLinks: true
---


## Condition handling in standard R

<style type="text/css">

  .reveal .slides .title {
    font-size: 125%;
    margin-bottom: 150px;
    color: black;
    text-transform: none;
  }

  .reveal .slides .author {
    font-size: 75%;
    color: grey;
    text-transform: none;
  }

  .reveal .slides .date {
    font-size: 75%;
    color: grey;
    text-transform: none;
  }

  .reveal .slide h1 {
    font-size: 40px;
    text-align: left;
    color: blue;
    text-transform: none;
  }

  .reveal .slide h2 {
    font-size: 30px;
    text-align: left;
    color: blue;
  }

  .reveal .slide h3 {
    font-size: 20px;
    text-align: left;
    color: blue;
  }

  .reveal section p {
    text-align: left;
    font-size: 70%;
  }

  .reveal section ul  {
    list-style-type: square;
    font-size: 70%;
  }
  
  .reveal section ol  {
    font-size: 70%;
  }

  .reveal section code {
    font-size: 90%;
    font-familie: Courier
  }

</style>



The execution of an R script can be interrupted to signal special *conditions* (states)

Examples:

- errors
- warnings
- messages
- user interrupts (by hitting CTRL + C/BRK or ESC)



## Condition examples

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE, error = TRUE)  # render R errors as output instead of stopping to knit
```

An error condition:
```{r, error = TRUE}
log("text")   # throws an error
```


A warning condition:
```{r, results='hold'}
log(-1)                # throws a warning
```



# Throw your own conditions

Note: This text will never be shown due to a "limitation by design" of pandoc:

http://stackoverflow.com/a/31778080/4468078



## Error

Based on a "condition" (expression) to recognize an invalid state:
```{r, error = TRUE}
if (1 != 2)
  stop("something is wrong")
```

Or shorter (but without a message text):
```{r, error = TRUE}
stopifnot(1 == 2)
```



## Warning

```{r}
warning("bad weather today, don't forget your umbrella")
```

## Message

```{r}
message("good morning")
```



# Handling conditions in R

Scroll down for examples...

## Unhandled errors stop R

By default R will stop the execution if an error occurs:
```{r, error = TRUE, eval = TRUE}
options(error = NULL)  # switch to default behaviour of R
{
  log("not a number")
  print("R does stop due to an error and never executes this line")
}
```
Note that the output does **not** show the `print` result since the execution stops in case of an error.



## Use `try` to ignore errors

With the `try` function you can handle errors to continue the execution (by ignoring the error):
```{r, collapse = FALSE, eval = TRUE}
{
  try(log("not a number"))
  print("errors can't stop me")
}
```



## Use `tryCatch` to handle errors

With `tryCatch` you can handle errors as you want:
```{r}
an.error.occured <- FALSE
tryCatch( { res <- log("not a number"); print(res) }
          , error = function(e) {an.error.occured <<- TRUE})
print(an.error.occured)
```

Note: If you use an error handler function the error is not shown anymore and the execution continues after
the `tryCatch` statement.



## `tryCatch` can handle all conditions 1/2

... not only errors. Just use the condition name as parameter to handle conditions of this type, e. g. a warning:

```{r}
tryCatch( { res <- log(-1); print("Done") }
          , warning = function(w) { print("Hey, a warning") })
```


## `tryCatch` can handle all conditions 1/2

You can use `error`, `warning`, `message` or `interrupt` as parameter name to assign a handler for these "standard" conditions:

```{r}
last.message <- NULL
tryCatch( { message("please handle me"); print("Done") }
          , message = function(m) { last.message <<- m })
print(last.message$message)
```



## User defined conditions

You can even define your own user-defined condition classes, but
there is no built in function to generate a new object of class condition.
So do it yourself:*

```{r}
condition <- function(subclass, message, call = sys.call(-1), ...) {
  structure( class = c(subclass, "condition"),
             list(message = message, call = call, ...))
}

tryCatch( { wc <- condition("work.condition", "after work party")
            signalCondition(wc); print("Done") }
          , work.condition = function(c) { print(c$message) })
```

User-defined condition classes are only required if you want to implement a specific recovery strategy for
this condition. This is out of scope of this presentation.

*) Source: <http://adv-r.had.co.nz/beyond-exception-handling.html>



## But `tryCatch` is not perfect

Have you discovered the problem in the previous examples?

See the next slides for the answer!


# The drawbacks of `tryCatch`

## 1. Handling a condition stops the execution 1/2

If you catch a warning (or another non-error condition) with `tryCatch` then R does

1. abort the execution of code that throwed the condition,
1. executes the handler function and
1. then continues the execution with the next command after the `tryCatch` command:

```{r, echo=FALSE}
# dummy code to avoid a "missing function" error in the next code junk
write.to.log <- function(msg) { invisible() }
```


```{r}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
tryCatch(f(), warning = function(w) { write.to.log(w) })
print("Done")
```

Observe: *Hello old world* is never printed! But normally you just want to log warnings without stopping the execution of the function `f()`.
It does **not** resume with the next command after the code that raised (throwed) the condition!



## 1. Handling a condition stops the execution 2/2

Compare: Calling the function without `tryCatch` does not stop the
execution of the function `f()`:

```{r}
{ # Execute as one block of code to show the output at the end only
  f <- function() {
    warning("deprecated function called")
    print("Hello old world")
  }
  f()
  print("Done")
}
```



## 2. Handling errors unrolls the stack trace 1/2

If you do **not catch an error** you can get the complete function call stack using `traceback`
which helps you to identify the code that throwed the error:

```{r, error = TRUE, eval = FALSE}
options(error=function() traceback(2)) # hack from: http://stackoverflow.com/a/13119318/4468078
f <- function() {
  log("not a number")
  print("Hello world")
}
f()
```

```{r, eval = FALSE}
Error in log("not a number") : 
  non-numeric argument to mathematical function
6: (function () 
   traceback(2))() at f.R#3
5: f() at f.R#6
...
1: source("f.R")
```



## 2. Handling errors unrolls the stack trace 2/2

But if you handle the error:

```{r, error = TRUE, eval = FALSE}
f <- function() {
  log("not a number")
  print("Hello world")
}
tryCatch(f(), error = function(e) { traceback() })
```

```{r, eval = FALSE}
8: value[[3L]](cond)
7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
6: tryCatchList(expr, classes, parentenv, handlers)
5: tryCatch(f(), error = function(e) {
       traceback(2)
   }) at f.R#5
...
1: source("f.R")
```

The call stack ends basically with the `tryCatch` call but does **not** show you the code in `f()`
where the error was thrown.


## Summary: The drawbacks of `tryCatch`

**How can you find out the exact reason for the error**

- without a full stack trace?
- if logging of warnings and messages is not possible without canceling
  the execution and resuming after `tryCatch`?



# Workaround 1: Interactive debugging

## Interactive debugging

You can run and debug your R script interactively in the *RGui* or [RStudio](https://www.rstudio.com/products/rstudio/).

For more details on interactive debugging see `?debug`.

**Note: Interactive debugging is out of scope of this presentation.**



## Limitations of interactive debugging

Interactive debugging is very difficult in case of

- errors that are not (easily) reproducible.
- long running code that produces an error at the end
- batch jobs running on a server



# Workaround 2: Use `withCallingHandlers` with `tryCatch`


## How `withCallingHandlers` works

`withCallingHandlers` works similar to `tryCatch` but

1. remembers the call stack down to the point where the condition was signaled
2. resumes the execution after the point where the condition was signaled

```{r}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
withCallingHandlers(f(), warning = function(w) { write.to.log(sys.calls()) })
print("Done")
```

`sys.calls` within `withCallingHandlers` returns the full call stack.



## `withCallingHandlers` with restarts

Restarts are used to recover from conditions using a predefined behaviour:

```{r, results = 'hold'}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
withCallingHandlers(f(), warning = function(w) { write.to.log(sys.calls())
                                                 invokeRestart("muffleWarning")})
print("Done")
```

`invokeRestart("muffleWarning")` has a simple recovery strategy: "Suppress the warning".

It removes the warning (so it cannot be handled anymore at higher function call levels)
and resumes the execution.



## Differences between `withCallingHandlers` and `tryCatch`

- `withCallingHandlers` remembers the call stack
- `tryCatch` unwinds the stack to the `tryCatch` call
- `withCallingHandlers` resumes execution in case of non-error conditions
- `tryCatch` breaks and continues after the `tryCatch` command

TODO: A table would be clearer!



## Combine `withCallingHandlers` with `tryCatch`

Requirements for better condition handling in R:

- Log all conditions on console or in file
- resume execution after warnings and messages
-  and continue after the handling function in case of an error

Solution:

- handle all conditions in `withCallingHandlers` to log them with the full stack trace
- to resume after a non-error condition invoke a restart in `withCallingHandlers`
- handle only errors in `tryCatch` to recover from the error and continue execution after `tryCatch`



## Implementation template

An improved "error handler" in R looks similar to this code pattern:
```{r, results='hold'}
f <- function() {
  warning("deprecated function called")
  print("A warning cannot stop me")
  log("not a number")
  print("Hello old world")
}

tryCatch(withCallingHandlers(f(), error = function(e)   { write.to.log(sys.calls()) }
                                , warning = function(w) { write.to.log(sys.calls())
                                                          invokeRestart("muffleWarning") })
         , error = function(e) { print("recovered from error") })
print("Done")
```



## Usability?

**Do you really want to use that much code in your R script at every place
where you have to catch errors and conditions?**

See the the next slides on how the package `tryCatchLog` could make your life easier!



# TODO

## ODOT

- sys.calls enthält keine source code references -> limitedLabels
- sys.calls (genau wie traceback) enthält auch viele R-interne Funktionsaufrufe,
  die für die Fehlersuche nicht hilfreich sind
- Kombi aus withCallingHandlers und tryCatch ist umständlich und lang

=> tryCatchLog

+ source code references
+ compact call stack (if available) 
+ Top-Feature: post-mortem analysis!
